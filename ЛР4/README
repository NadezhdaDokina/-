ДЕРЕВО- иерархическая структура данных, состоящая из узлов, каждый из которых обладает одним родителем (за исключением корневого узла) и может иметь несколько дочерних элементов. Корень дерева не имеет родителей, а листья не содержат потомков. Такая структура широко применяется, например, в организации файловых систем компьютеров и корпоративных организационных схемах.
Структура дерева включает одну особую вершину — корень, от которой направляются рёбра ко всем остальным узлам. Каждая вершина, кроме корня, имеет ровно одно входящее ребро, тогда как сам корень не имеет входящих рёбер. Классическими примерами деревьев являются структуры папок в файловой системе компьютера и генеалогическое древо семьи.
ГРАФ — это нелинейная структура данных, состоящая из узлов (вершин) и ребер (связей между узлами). Граф представляет собой набор из U элементов (вершин/узлов) и E рёбер, причём ребро можно представить парой e=[x,y].  Графы могут быть ориентированными  и неориентированными , взвешенными и нет. А также графы используются для моделирования сетей.

РЕАЛИЗАЦИЯ ДЕРЕВЬЕВ И ГРАФОВ НА PYTHON, JAVA И C++

ПРИМЕР ДЕРЕВА НА PYTHON
`class TreeNode: def init(self, value): self.value = value self.children = []
def add_child(self, child):
    self.children.append(child)
ИСПОЛЬЗОВАНИЕ:
root = TreeNode(1) root.add_child(TreeNode(2)) root.add_child(TreeNode(3))
АНАЛИЗ:
Класс `TreeNode` служит основой для представления узлов дерева, хранит значение конкретной вершины и перечень её дочерних элементов. Эта простая и гибкая структура позволяет эффективно дополнять класс нужными методами для поиска, обхода и других операций над деревом. В каждом экземпляре класса хранится собственное значение и ссылка на подчинённые вершины, что обеспечивает лёгкость расширения функциональности для манипуляций и навигации по структуре дерева.



ПРИМЕР ГРАФА НА JAVA
import java.util.ArrayList; import java.util.List;

class GraphVertex { int id; List neighbors;

public GraphVertex(int id) {
    this.id = id;
    this.neighbors = new ArrayList<>();
}

public void addNeighbor(GraphVertex vertex) {
    neighbors.add(vertex);
}
ИСПОЛЬЗОВАНИЕ:
GraphVertex A = new GraphVertex(1); GraphVertex B = new GraphVertex(2); A.addNeighbor(B); B.addNeighbor(A);
АНАЛИЗ:
Граф удобно представлять посредством списков смежности, где каждая вершина хранит список своих соседних вершин. Такой метод эффективен для внесения динамических изменений в граф и оптимален с точки зрения потребления памяти. Список смежности обеспечивает простую реализацию графа, позволяя быстро добавлять новые элементы и изменять существующие связи, сохраняя компактность структуры.



ПРИМЕР ФОРМИРОВАНИЯ ГРАФА НА C++
`#include #include

using namespace std;

class Vertex { public: int id; vector<Vertex*> neighbors;

Vertex(int id) : id(id) {}

void addNeighbor(Vertex* neighbor) {
    neighbors.push_back(neighbor);
}
};
ИСПОЛЬЗОВАНИЕ:
 Пример использования int main() { Vertex A(1), B(2); A.addNeighbor(&B); B.addNeighbor(&A); return 0; }`
АНАЛИЗ:
Данная реализация, похожая на используемую в Java, основана на применении ссылок на объекты, что способствует повышению производительности и уменьшению расхода оперативной памяти.
Подробный разбор алгоритма обхода дерева методом поиска в глубину (DFS) на языке Python. Мы рассмотрим базовую версию DFS, которая последовательно рекурсивно проходит по вершинам, фиксирует посещенные узлы и эффективно решает широкий спектр задач обработки древесных структур.

def dfs(node): visited = set() stack = [node]

while stack:
current = stack.pop()
if current not in visited:
    visited.add(current)
    print(current.value)
    stack.extend(reversed(current.children))
ПРИМЕР ИСПОЛЬЗОВАНИЯ:
Вызов функции обхода dfs(root) начинается с корня дерева. Алгоритм работает со стеком, в который помещаются вершины, и продолжает обработку, пока стек не опустеет. Каждая вершина посещается только один раз: сначала выводится её значение, затем в стек добавляются её дочерние узлы в обратном порядке, чтобы обеспечить правильную последовательность обхода.

ОЦЕНКА ВРЕМЕННОЙ СЛОЖНОСТИ
Посещение каждой вершины происходит ровно один раз. Каждый ребро также рассматривается один раз при переходе от родителя к ребёнку. Общая временная сложность алгоритма DFS для дерева с N вершинами и E рёбрами:O(N+E).
