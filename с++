Сортировка выбором (Selection Sort) 

#include <iostream>   // Подключаем библиотеку ввода-вывода

using namespace std;  // Используем пространство имен std для упрощения записи стандартных функций и типов

// Функция для сортировки массива методом выбора
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {                // Проходим по массиву от начала до предпоследнего элемента
        int minIndex = i;                            // Предполагаем, что минимальный элемент находится на текущей позиции
        
        // Ищем наименьший элемент справа от текущего индекса
        for (int j = i + 1; j < n; ++j) {            // Начинаем проверку следующего элемента
            if (arr[j] < arr[minIndex])              // Если найден меньший элемент
                minIndex = j;                        // Запоминаем индекс нового минимума
        }
    
        // Меняем местами текущий элемент и найденный минимум
        swap(arr[i], arr[minIndex]);                 // Выполняем обмен значений
    }
}

// Основная программа
int main() {
    int arr[] = {64, 25, 12, 22, 11};               // Пример массива для сортировки
    int n = sizeof(arr)/sizeof(arr[0]);              // Определяем размер массива

    cout << "Исходный массив: ";
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";                       // Вывод исходного массива

    selectionSort(arr, n);                           // Сортируем массив

    cout << "\nОтсортированный массив: ";
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";                       // Вывод отсортированного массива

    return 0;                                        // Завершаем программу успешно
}




Сортировка слиянием (Merge Sort) 


#include <iostream>      // Стандартная библиотека ввода-вывода
using namespace std;     // Пространство имен std для удобства обращения к функциям

// Вспомогательная функция для объединения двух отсортированных подпоследовательностей
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;          // Размер левой половины
    int n2 = right - mid;             // Размер правой половины

    // Временные массивы для хранения обеих половинок
    int L[n1], R[n2];

    // Копируем левую половину в массив L
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];           // Перемещаемся по левой половине

    // Копируем правую половину в массив R
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];       // Перемещаемся по правой половине

    // Индексы для левого и правого временных массивов и основной последовательности
    int i = 0, j = 0, k = left;

    // Объединение половинок путем сравнения элементов
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {            // Если левый элемент меньше или равен правому
            arr[k++] = L[i++];         // Добавляем левый элемент и увеличиваем индексы
        } else {
            arr[k++] = R[j++];         // Иначе добавляем правый элемент и увеличиваем индексы
        }
    }

    // Перенос оставшихся элементов из левой половины, если они остались
    while (i < n1) {
        arr[k++] = L[i++];
    }

    // Перенос оставшихся элементов из правой половины, если они остались
    while (j < n2) {
        arr[k++] = R[j++];
    }
}

// Рекурсивная функция сортировки слиянием
void mergeSort(int arr[], int left, int right) {
    if (left >= right)                     // Базовый случай: если диапазон пуст или содержит всего один элемент
        return;

    int mid = left + (right - left) / 2;  // Срединный индекс массива
    mergeSort(arr, left, mid);             // Сортировка левой половины
    mergeSort(arr, mid + 1, right);        // Сортировка правой половины
    merge(arr, left, mid, right);          // Объединение двух отсортированных половин
}

// Главная функция программы
int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10}; // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]);    // Вычисление размера массива

    cout << "Исходный массив: ";
    for (int i = 0; i < n; i++)              // Печать исходного массива
        cout << arr[i] << " ";
    cout << endl;

    mergeSort(arr, 0, n - 1);                // Вызов функции сортировки

    cout << "Отсортированный массив: ";
    for (int i = 0; i < n; i++)              // Печать отсортированного массива
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}


Быстрая сортировка (Quick Sort)


#include <iostream>  // Включаем стандартную библиотеку ввода-вывода
using namespace std; // Используем пространство имен std

// Вспомогательная функция для обмена элементами массива
void swap(int& a, int& b) {
    int temp = a;   // Сохраняем первое значение временно
    a = b;          // Присваиваем первому элементу второе значение
    b = temp;       // Присваиваем второму элементу сохранённое временное значение
}

// Процедура partition: размещает pivot и возвращает его новую позицию
int partition(int arr[], int low, int high) {
    int pivot = arr[high];                      // Выбираем крайний правый элемент в качестве pivot'а
    int i = (low - 1);                          // Индекс меньшей секции

    // Цикл прохождения по сегменту массива
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {                   // Если текущий элемент меньше pivot'а
            i++;                                // Увеличиваем индекс меньшей секции
            swap(arr[i], arr[j]);               // Меняем элементы местами
        }
    }
    swap(arr[i + 1], arr[high]);                // Ставим pivot на правильное место
    return (i + 1);                             // Возвращаем индекс pivot'а
}

// Основная процедура quick sort
void quickSort(int arr[], int low, int high) {
    if (low < high) {                           // Пока сегмент больше одного элемента
        int pi = partition(arr, low, high);      // Делим массив на две части и получаем индекс pivot'а
        quickSort(arr, low, pi - 1);            // Рекурсивно сортируем левую часть
        quickSort(arr, pi + 1, high);           // Рекурсивно сортируем правую часть
    }
}

// Тестирующая основная функция
int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};           // Наш тестовый массив
    int n = sizeof(arr) / sizeof(arr[0]);       // Определяем размер массива
    quickSort(arr, 0, n - 1);                   // Вызываем процедуру быстрой сортировки
    cout << "Отсортированный массив:\n";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";                  // Выводим отсортированный массив
    return 0;
}



Пирамидальная сортировка


#include <iostream>  // Подключаем библиотеку ввода-вывода
using namespace std; // Пространство имен std для удобного обращения к библиотечным функциям

// Вспомогательная функция для восстановления свойства кучи снизу вверх
void heapify(int arr[], int n, int root) {
    int largest = root;          // Корень принимается за наибольший элемент
    int leftChild = 2 * root + 1;// Рассчитываем индекс левого потомка
    int rightChild = 2 * root + 2;// Рассчитываем индекс правого потомка

    // Проверяем, существует ли левый потомок и больше ли он корня
    if (leftChild < n && arr[leftChild] > arr[largest])
        largest = leftChild;

    // Аналогично проверяем правого потомка
    if (rightChild < n && arr[rightChild] > arr[largest])
        largest = rightChild;

    // Если наибольший элемент оказался не корнем, производим замену
    if (largest != root) {
        swap(arr[root], arr[largest]); // Меняем местами корень и наибольшего сына
        heapify(arr, n, largest);     // Рекурсивно восстанавливаем кучу сверху вниз
    }
}

// Основная функция пирамидальной сортировки
void heapSort(int arr[], int n) {
    // Построение max-кучи (преобразование массива в кучу)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);  // Восстанавливаем свойство кучи для каждого узла

    // Процесс извлечения максимального элемента из кучи и построения отсортированного массива
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]); // Максимальный элемент (корень) отправляется в конец массива
        heapify(arr, i, 0);   // Восстанавливаем кучу после удаления максимума
    }
}

// Основная функция программы
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7}; // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]); // Определили размер массива

    cout << "Исходный массив: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    heapSort(arr, n); // Вызвали процедуру сортировки

    cout << "Отсортированный массив: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}



Интерполирующий поиск


#include <iostream>  // Подключаем библиотеку ввода-вывода
using namespace std;  // Используем пространство имен std

// Функция интерполирующего поиска
int interpolateSearch(int arr[], int size, int target) {
    int low = 0;              // Нижняя граница поиска
    int high = size - 1;      // Верхняя граница поиска

    while ((arr[high] != arr[low]) && (target >= arr[low]) && (target <= arr[high])) {
        // Вычисляем приближённую позицию искомого элемента
        int pos = low + (((double)(high - low) /
                         (arr[high] - arr[low])) *
                        (target - arr[low]));

        // Если элемент найден, возвращаем его индекс
        if (arr[pos] == target)
            return pos;

        // Изменяем границы поиска в зависимости от значения в текущей позиции
        if (arr[pos] < target)
            low = pos + 1;    // Искать справа
        else
            high = pos - 1;   // Искать слева
    }

    // Последняя проверка, если совпадение произошло на границах
    if (target == arr[low])
        return low;
    else
        return -1;            // Элемент не найден
}

// Основная функция
int main() {
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int size = sizeof(arr) / sizeof(arr[0]);  // Определяем размер массива
    int target = 18;                         // Целевой элемент для поиска

    int index = interpolateSearch(arr, size, target);

    if (index != -1)
        cout << "Элемент " << target << " найден на позиции " << index << endl;
    else
        cout << "Элемент " << target << " не найден." << endl;

    return 0;
}
