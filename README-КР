блочная (корзинная) сортировка

Определение алгоритма блочной (корзинной) сортировки:
Блочная (корзинная) сортировка — это алгоритм сортировки, который особенно эффективен для больших массивов данных, где элементы распределены равномерно. Основная идея заключается в том, чтобы разделить элементы на несколько "корзин" (или "блоков") ) в зависимости от диапазона их 
значений, а затем отсортировать каждую корзину отдельно. Этот алгоритм особенно полезен для сортировки чисел с плавающей точкой или других данных, которые можно равномерно распределить по диапазону.

Объяснение работы алгоритма:
  Распределение по корзинам: index = int(num * n / (max(arr) + 1))
                             buckets[index].append(num)
Элементы массива распределяются по корзинам на основе их значений. Это позволяет разбить массив на более мелкие части, которые легче отсортировать.
  Сортировка каждой корзины: for i in range(n):
                             buckets[i].sort()
Каждая корзина сортируется отдельно. Это эффективно, так как корзины содержат небольшое количество элементов.
  Сборка результатов: result = []
                      for bucket in buckets:
                      result.extend(bucket)
После сортировки каждой корзины, элементы собираются в один итоговый массив, который является отсортированным.

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n + k), где n — количество элементов в массиве, а k — количество элементов в корзине. В среднем, если элементы распределены равномерно, k будет небольшим.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n + k), так как распределение по корзинам и сборка результатов занимают O(n), а сортировка каждой корзины занимает O(k).




блинная сортировка

Определение алгоритма блинной сортировки:
Блинная сортировка (Pancake Sort) — это алгоритм сортировки, который использует только одну операцию: переворот (flip) части массива. Основная идея заключается в том, чтобы найти максимальный элемент в неотсортированной части массива, переместить его в начало, а затем перевернуть всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте.

Объяснение работы алгоритма:
  Переворот максимального элемента:
На каждой итерации мы находим максимальный элемент в неотсортированной части массива и перемещаем его в начало с помощью переворота.
  Перемещение максимального элемента на свое место:
После того как максимальный элемент оказался в начале, мы переворачиваем всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте.
  Повторение процесса:
Процесс повторяется для каждой неотсортированной части массива, пока весь массив не будет отсортирован.

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n^2), так как на каждой итерации мы проходим по массиву для нахождения максимального элемента и выполняем два переворота.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n^2), так как на каждой итерации мы выполняем два переворота и находим максимальный элемент, что требует O(n) операций.


сортировка бусинами (гравитационная) 

Определение алгоритма сортировки бусинами (гравитационная сортировка):
Сортировка бусинами (также известная как гравитационная сортировка) — это визуальный и интуитивно понятный алгоритм сортировки, который имитирует процесс падения бусин через вертикальные стержни. Основная идея заключается в том, что бусины падают вниз, и в результате они выстраиваются в порядке возрастания.

Объяснение работы алгоритма:
  Создание матрицы:
Мы создаем матрицу, где каждая строка представляет элемент массива. Например, для массива [5, 3, 1, 4, 2] матрица будет выглядеть так:[    
                                                                                                                                        [1, 1, 1, 1, 1],  # 5   
                                                                                                                                        [1, 1, 1, 0, 0],  # 3 
                                                                                                                                        [1, 0, 0, 0, 0],  # 1 
                                                                                                                                        [1, 1, 1, 1, 0]   # 4
                                                                                                                                        [1, 1, 0, 0, 0]   # 2 
                                                                                                                                                              ]
  "Падение" бусин вниз:
Мы транспонируем матрицу, сортируем каждый столбец в обратном порядке и транспонируем обратно. В результате "бусины" падают вниз, и матрица выглядит так: [    
                                                                                                                                                              [1, 1, 1, 1, 1],  # 5   
                                                                                                                                                              [1, 1, 1, 1, 0]   # 4
                                                                                                                                                              [1, 1, 1, 0, 0],  # 3
                                                                                                                                                              [1, 1, 0, 0, 0]   # 2 
                                                                                                                                                              [1, 0, 0, 0, 0]   # 1
                                                                                                                                                                                      ]

  Преобразование матрицы обратно в массив:
Мы суммируем каждый ряд матрицы, чтобы получить отсортированный массив: [1, 2, 3, 4, 5].

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n * max(arr)), где n — количество элементов в массиве, а max(arr) — максимальный элемент в массиве.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n * max(arr)), так как мы создаем матрицу размером n * max(arr) и выполняем операции с ней.





поиск скачками
Определение алгоритма поиска скачками:
Поиск скачками (Jump Search) — это алгоритм поиска, который сочетает в себе элементы линейного и бинарного поиска. Основная идея заключается в том, чтобы "прыгать" по массиву с определенным шагом, а затем выполнять линейный поиск в окрестности найденного элемента.

Объяснение работы алгоритма:
  Определение размера шага:
Мы используем квадратный корень из длины массива в качестве размера шага. Это позволяет нам эффективно "прыгать" по массиву.
  Поиск блока:
Мы "прыгаем" по массиву с шагом step, пока не найдем блок, в котором может находиться искомый элемент.
  Линейный поиск в блоке:
После того как мы нашли блок, мы выполняем линейный поиск в этом блоке, чтобы найти искомый элемент.
  Проверка результата:
Если элемент найден, возвращаем его позицию. Если нет, возвращаем -1.

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(√n), где n — длина массива.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(√n), так как мы выполняем √n прыжков и линейный поиск в блоке.





экспоненциальный поиск
Определение алгоритма экспоненциального поиска:
Экспоненциальный поиск (Exponential Search) — это алгоритм поиска, который сочетает в себе элементы линейного и бинарного поиска. Основная идея заключается в том, чтобы сначала найти диапазон, в котором может находиться искомый элемент, а затем выполнить бинарный поиск в этом диапазоне.

Объяснение работы алгоритма:
  Поиск диапазона:
Мы начинаем с индекса 1 и удваиваем его, пока не найдем элемент, который больше или равен искомому. Это позволяет нам найти диапазон, в котором может находиться искомый элемент.
  Бинарный поиск:
После того как мы нашли диапазон, мы выполняем бинарный поиск в этом диапазоне, чтобы найти искомый элемент.
  Проверка результата:
Если элемент найден, возвращаем его позицию. Если нет, возвращаем -1.

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(log n), где n — длина массива.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(log n), так как мы выполняем log n шагов для поиска диапазона и бинарный поиск в этом диапазоне.





тернарный поиск

Определение алгоритма тернарного поиска:
Тернарный поиск (Ternary Search) — это алгоритм поиска, который похож на бинарный поиск, но вместо деления массива на две части, он делит его на три. Основная идея заключается в том, чтобы найти минимум или максимум функции на отрезке, используя два среза.

Принцип работы (для массива): 
1. Делится диапазон индексов на три части. 
2. Сравнивается искомый элемент с элементами на двух разделительных границах. 
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети 
массива, где может находиться искомое значение.

Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(log n), где n — длина массива.

Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(log n), так как мы выполняем log n шагов для поиска элемента.



