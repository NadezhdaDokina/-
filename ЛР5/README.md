Вариант 6. Создайте рекурсивную функцию для подсчета количества гласных букв в строке.

PYTHON
Шаги выполнения:

1. Базовый случай рекурсии

python
if index >= len(s):
    return 0
Проверяется, достиг ли индекс конца строки (index >= длина строки).

Если да — возвращаем 0 (больше символов нет, рекурсия завершается).

Это предотвращает выход за границы строки и задаёт «точку остановки» рекурсии.

2. Обработка текущего символа

python
current_char = s[index].lower()
Получаем символ по текущему индексу: s[index].

Приводим его к нижнему регистру с помощью .lower(), чтобы учитывать и заглавные, и строчные гласные.

 3. Проверка на гласную

python
if current_char in 'aeiou':
Проверяем, входит ли символ в строку 'aeiou' (набор английских гласных).

Оператор in возвращает True, если символ найден, иначе False.

 4. Рекурсивный вызов

Если гласная:

python
return 1 + count_vowels(s, index + 1)
Прибавляем 1 (нашли гласную) и вызываем функцию для следующего индекса (index + 1).

Если не гласная:

python
return count_vowels(s, index + 1)
Вызываем функцию для следующего индекса без прибавления.

Временная сложность: 
Итоговая оценка: O(n), где n — длина входной строки
Почему?
Алгоритм имеет линейную временную сложность O(n), так как:
каждый символ строки обрабатывается ровно один раз;
все операции внутри рекурсивного вызова выполняются за константное время;
глубина рекурсии прямо пропорциональна длине строки.


JAVA
Шаги выполнения:

1.Инициализация

Функция запускается с index = 0 (начало строки).

При последующих вызовах index увеличивается на 1.

2.Базовый случай (остановка рекурсии)

Если index >= длина строки → возвращаем 0 (больше символов нет).

Это предотвращает выход за границы массива и завершает рекурсию.

3.Обработка текущего символа

Получаем символ по текущему индексу: str.charAt(index).

Приводим к нижнему регистру: Character.toLowerCase() (чтобы учитывать A и a).

4.Проверка на гласную

Используем "aeiou".indexOf(current) != -1 для проверки принадлежности к гласным.

Альтернатива: цепочка || (например, current == 'a' || current == 'e'...).

5.Рекурсивный вызов

Если символ — гласная: возвращаем 1 + результат_рекурсии.
Иначе: возвращаем результат_рекурсии (без прибавления).

Рекурсия продолжается с index + 1.

6.Сборка результата

Значения накапливаются при возврате из рекурсивных вызовов.

Итоговая сумма — количество гласных в строке.

Временная сложность: O(n)
Где n — длина входной строки
Алгоритм имеет линейную временную сложность O(n), так как:
Глубина рекурсии равна n+1
все операции внутри рекурсивного вызова выполняются за константное время;
Каждый вызов добавляет фрейм в стек вызовов (содержит параметры и локальные переменные).
Это оптимально для задачи, требующей анализа каждого символа входной строки.

C++
Шаги выполнения:

1.Ввод строки от пользователя:

cpp
std::cout << "Введите строку для анализа: ";
std::getline(std::cin, input);
Выводит приглашение.

Считывает строку (включая пробелы) с помощью std::getline.

2.Подсчёт гласных во введённой строке:

cpp
int result1 = countVowels(input);
std::cout << "Количество гласных: " << result1 << std::endl;
3.Тестирование на фиксированных примерах:

Создаются тестовые строки (test1, test2, и т. д.).

Для каждой строки вызывается countVowels() и выводится результат.
временная сложность всей программы составляет O(n).

Почему именно такая временная сложность?
Операция сравнения: Каждый символ обрабатывается ровно один раз независимо от его положения в строке. Операций проверки ("гласная или нет") выполняется столько же, сколько символов в строке.
Рекурсия: Хотя используется рекурсивный подход, глубина рекурсии линейна относительно длины строки. Каждое рекурсивное погружение увеличивает индекс на единицу, пока не достигнет последнего символа строки.
Итог: алгоритм последовательно сканирует всю строку слева направо, выполняя фиксированную работу на каждом шаге, следовательно, временная сложность линейна по размеру входных данных.


ВОПРОС 7
Временная сложность задачи о N ферзях зависит от выбранного алгоритма решения. Рассмотрим основные подходы.

1. Полный перебор (наивный алгоритм)
Сложность: O(N!) (факториальная).
Почему так:

На 1‑й вертикали перебираем N позиций для ферзя.
На 2‑й вертикали — не более N−1 позиций (исключая битые поля).
На 3‑й — не более N−2, и т. д.
В худшем случае число вариантов растёт как N×(N−1)×(N−2)×…×1=N!.
Особенности:
Практически неприменим уже при N>12 из‑за взрывного роста числа вариантов.
Требует проверки каждой расстановки на отсутствие атак по строкам, столбцам и диагоналям.
2. Поиск с возвратом (backtracking)
Сложность в худшем случае: O(N!), но на практике значительно быстрее.
Как работает:
Размещаем ферзей по одному в каждой вертикали (по столбцам).
Для каждого нового ферзя проверяем, не бьёт ли он уже расставленных.
Если конфликт — откат (backtrack) и проба следующей позиции.
Если позиция найдена — переходим к следующему столбцу.
Почему O(N!) в худшем случае:
В худшем сценарии алгоритм всё равно перебирает почти все перестановки.
Но на практике множество вариантов отсекается рано, поэтому реальное время сильно меньше N!.

Итог:
Теоретическая нижняя граница: задача требует перебора экспоненциального числа вариантов, поэтому полиномиального алгоритма не существует (если только P=NP).
Практический стандарт: алгоритм с возвратом (O(N!)) — основной способ точного решения для N≤20–25.
Для больших N: используют эвристики и приближённые методы, снижающие эффективную сложность, но без гарантий полноты.
