
АНАЛИЗ АЛГОРИТМА: сортировка выбором (Selection Sort)
Определение: Алгоритм, который делится на две зоны: первая зоны содержит уже отсортированные элементы, вторая — ещё неупорядоченные. На каждом шаге алгоритм ищет наименьший элемент в зоне неотсортированных элементов и помещает его в начало этой зоны, таким образом расширяя зону отсортированных элементов.
Анализ: Алгоритм сортировки выбором последовательно просматривает массив, отыскивает наименьший элемент и размещает его в начало текущей несортированной части. Процесс повторяется для оставшейся части массива до его полной сортировки. 
Временная сложность данного метода — O(n^2), что делает его малопригодным для обработки крупных объемов данных. Пространственная сложность алгоритма — O(1) благодаря минимальному объему дополнительной памяти, необходимой для работы.

АНАЛИЗ АЛГОРИТМА: сортировка обменом (пузырьком) (Bubble Sort)
Определение: это простой алгоритм сортировки, при которой соседние элементы массива попарно сравниваются и меняют места, если нарушают порядок. 
Анализ:алгоритм производит серию проходов по массиву, постепенно передвигая крупные элементы к концу. Чем больше проходов сделано, тем больше вероятность того, что массив уже отсортирован, позволяя завершить процедуру досрочно.
Данный алгоритм обладает временной сложностью O(n²) и пространственной сложностью O(1).

АНАЛИЗ АЛГОРИТМА: сортировка вставками (Insertion Sort)
Определение: это простой алгоритм сортировки, работающий следующим образом: перебираются элементы массива слева направо, и каждый элемент вставляется на своё правильное место среди ранее отсортированных элементов. Этот метод похож на процесс упорядочивания карт вручную.
Анализ:
Временная сложность в худшем и среднем случаях составляет O(n²), но в наилучшем случае, когда массив уже отсортирован, достигается O(n)

АНАЛИЗ АЛГОРИТМА: Сортировка слиянием (Merge Sort)
Определение:
Анализ:
Временная сложность алгоритма — 0(n log n)

АНАЛИЗ АЛГОРИТМА: Сортировка Шелла (Shell Sort)
Определение: это модификация классической сортировки вставками, где сначала элементы сортируются с некоторым фиксированным шагом («gap»), а затем шаг уменьшается до единицы, превращая алгоритм в классическую сортировку вставками.
Анализ:
временная сложность в среднем остается около 0(N^1,25), хотя для некоторых случаев может достигать 0(N^2)

АНАЛИЗ АЛГОРИТМА: Быстрая сортировка (Quick Sort)
Определение:
Анализ:
Средняя временная сложность алгоритма — O(nlog⁡n).

АНАЛИЗ АЛГОРИТМА: Пирамидальная сортировка (Heap Sort)
Определение:
Анализ:
Временная сложность алгоритма — O(nlog⁡n).

АНАЛИЗ АЛГОРИТМА: Последовательный (линейный) поиск (Linear Search)
Определение: это простой метод нахождения заданного значения в списке путем пошагового просмотра элементов вплоть до обнаружения искомого значения либо завершения проверки всего списка.
Анализ:
Средняя временная сложность остаётся O(N)

АНАЛИЗ АЛГОРИТМА: Бинарный поиск (Binary Search)
Определение: это эффективный способ поиска элемента в отсортированном массиве. Благодаря быстрому снижению размеров зоны поиска, он обладает временем работы O(logN), что делает его незаменимым инструментом в ситуациях, когда важна высокая производительность поиска.
Анализ:Его основная идея заключается в последовательном делении диапазона поиска пополам, исключая половину возможных вариантов на каждом шаге. 
Временная сложность алгоритма бинарного поиска составляет 0(log N), где N — длина массива. Это гораздо эффективнее классических методов типа простого перебора 0(N)

АНАЛИЗ АЛГОРИТМА: Интерполирующий поиск (Interpolation Search)
Определение: это улучшенная версия обычного бинарного поиска, предназначенная для быстрого нахождения элементов в больших упорядоченных наборах данных, особенно если распределение элементов равномерное. Интерполирующий поиск рассчитывает вероятную позицию искомого элемента, основываясь на характеристиках распределения данных. 
Анализ:
Временная сложность в лучшем случае — O(log⁡log⁡n), в худшем — O(n)

АНАЛИЗ АЛГОРИТМА: Поиск по Фибоначчи (Fibonacci Search)
Определение: это улучшенный вариант бинарного поиска, использующий числа последовательности Фибоначчи для деления области поиска. Вместо равномерного разделения диапазона пополам, как в обычном бинарном поиске, здесь используются коэффициенты из ряда Фибоначчи для выбора точки разделителя. Этот метод обеспечивает меньшую глубину рекурсии и потенциально быстрее работает на некоторых структурах данных.
Анализ:
Средняя сложность также остается близкой к логарифмической, O(log N).
