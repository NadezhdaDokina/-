# ==== Установка и импорты (ячейка Colab) ====
!pip install yfinance --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

class TimeSeriesPredictor:
    def __init__(self, window_size=60):
        self.window_size = window_size
        self.model = self._build_model()
        self.scaler = MinMaxScaler(feature_range=(0, 1))
        self.history = None  # для хранения истории обучения

    def _build_model(self):
        model = Sequential()
        model.add(
            LSTM(
                50,
                return_sequences=False,
                input_shape=(self.window_size, 1)
            )
        )
        model.add(Dense(25))
        model.add(Dense(1))
        # mse как метрика «точности», loss = mse
        model.compile(optimizer='adam',
                      loss='mean_squared_error',
                      metrics=['mse'])
        return model

    def prepare_data(self, data):
        X, y = [], []
        for i in range(self.window_size, len(data)):
            X.append(data[i-self.window_size:i, 0])
            y.append(data[i, 0])
        X = np.array(X)
        y = np.array(y)
        X = np.reshape(X, (X.shape[0], X.shape[1], 1))
        return X, y

    def normalize(self, data):
        return self.scaler.fit_transform(data)

    def inverse_transform(self, data):
        return self.scaler.inverse_transform(data)

    def train(self, X_train, y_train,
              epochs=50, batch_size=32, validation_split=0.1):
        # сохраняем history, чтобы затем построить графики
        self.history = self.model.fit(
            X_train, y_train,
            epochs=epochs,
            batch_size=batch_size,
            validation_split=validation_split,
            verbose=1
        )

    def predict(self, last_window):
        window = np.array(last_window)
        if window.ndim == 1:
            window = window.reshape(-1, 1)
        window = np.reshape(window, (1, self.window_size, 1))
        pred_scaled = self.model.predict(window)
        pred = self.inverse_transform(pred_scaled)
        return pred[0, 0]

    # ===== ВИЗУАЛИЗАЦИЯ ОБУЧЕНИЯ =====

    def plot_loss_and_accuracy(self):
        """
        Графики:
        1) Функция потерь (loss) train/val.
        2) Точность (mse) train/val.
        """
        if self.history is None:
            print("Модель ещё не обучалась.")
            return

        # График функции потерь
        plt.figure(figsize=(12, 4))

        plt.subplot(1, 2, 1)
        plt.plot(self.history.history['loss'], label='Train loss')
        plt.plot(self.history.history['val_loss'], label='Val loss')
        plt.title('Функция потерь: обучение и валидация')
        plt.xlabel('Эпоха')
        plt.ylabel('Loss')
        plt.legend()
        plt.grid(True)

        # График «точности» (mse) обучения и валидации
        plt.subplot(1, 2, 2)
        plt.plot(self.history.history['mse'], label='Train mse')
        plt.plot(self.history.history['val_mse'], label='Val mse')
        plt.title('Точность (MSE): обучение и валидация')
        plt.xlabel('Эпоха')
        plt.ylabel('MSE')
        plt.legend()
        plt.grid(True)

        plt.tight_layout()
        plt.show()
        # ==== Загрузка данных ====
ticker = "AAPL"
df = yf.download(ticker, start="2015-01-01", end="2024-12-31")
prices = df[["Close"]].values   # берём цену закрытия

# ==== Подготовка ====
window_size = 60
predictor = TimeSeriesPredictor(window_size=window_size)

scaled_prices = predictor.normalize(prices)

train_size = int(len(scaled_prices) * 0.8)
train_data = scaled_prices[:train_size]
test_data = scaled_prices[train_size - window_size:]

X_train, y_train = predictor.prepare_data(train_data)
X_test, y_test = predictor.prepare_data(test_data)

# ==== Обучение ====
predictor.train(X_train, y_train,
                epochs=50,
                batch_size=32,
                validation_split=0.1)

# ==== Предсказания на тесте ====
predictions_scaled = predictor.model.predict(X_test)
predictions = predictor.inverse_transform(predictions_scaled)
y_test_real = predictor.inverse_transform(y_test.reshape(-1, 1))

# ==== Визуализация предсказаний ====
plt.figure(figsize=(14, 6))
plt.plot(df.index[train_size:], y_test_real, label='Реальная цена')
plt.plot(df.index[train_size:], predictions, label='Прогноз LSTM')
plt.title(f'Прогноз цен акции {ticker}')
plt.xlabel('Дата')
plt.ylabel('Цена закрытия')
plt.legend()
plt.grid(True)
plt.show()

# ==== Графики точности и функции потерь ====
predictor.plot_loss_and_accuracy()

