блочная (корзинная) сортировка
def bucket_sort(arr):
    # Шаг 1: Определяем количество корзин
    # Обычно количество корзин выбирается равным длине массива
    n = len(arr)
    buckets = [[] for _ in range(n)]

    # Шаг 2: Распределяем элементы по корзинам
    # Для этого используем формулу для индекса корзины
    for num in arr:
        # Индекс корзины определяется как (число * количество корзин) / (максимальное значение + 1)
        # Это позволяет равномерно распределить элементы по корзинам
        index = int(num * n / (max(arr) + 1))
        buckets[index].append(num)

    # Шаг 3: Сортируем каждую корзину
    # Используем встроенную функцию сортировки для каждой корзины
    for i in range(n):
        buckets[i].sort()

    # Шаг 4: Собираем отсортированные элементы из корзин
    # Проходим по всем корзинам и добавляем элементы в итоговый массив
    result = []
    for bucket in buckets:
        result.extend(bucket)

    return result

# Пример использования
if __name__ == "__main__":
    arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23]
    sorted_arr = bucket_sort(arr)
    print("Отсортированный массив:", sorted_arr)
Результаты работы кода:
Исходный массив: [0.89, 0.25, 0.58, 0.99, 0.45, 0.33, 0.21, 0.8, 0.77, 0.68]
Отсортированный массив: [0.21, 0.25, 0.33, 0.45, 0.58, 0.68, 0.77, 0.8, 0.89, 0.99]


блинная сортировка

def flip(arr, k):
    # Переворачиваем первые k элементов массива
    arr[:k] = arr[:k][::-1]

def find_max_index(arr, n):
    # Находим индекс максимального элемента в неотсортированной части массива
    max_index = 0
    for i in range(n):
        if arr[i] > arr[max_index]:
            max_index = i
    return max_index

def pancake_sort(arr):
    # Основная функция блинной сортировки
    n = len(arr)
    for current_size in range(n, 1, -1):
        # Находим индекс максимального элемента в текущей неотсортированной части массива
        max_index = find_max_index(arr, current_size)
        
        # Если максимальный элемент уже на своем месте, пропускаем итерацию
        if max_index != current_size - 1:
            # Переворачиваем массив так, чтобы максимальный элемент оказался в начале
            flip(arr, max_index + 1)
            # Переворачиваем всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте
            flip(arr, current_size)

# Пример использования
if __name__ == "__main__":
    arr = [3, 6, 2, 4, 5, 1]
    pancake_sort(arr)
    print("Отсортированный массив:", arr)

Результаты работы кода:
Изначальный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]




сортировка бусинами (гравитационная)

def bead_sort(arr):
    # Шаг 1: Создаем матрицу, где каждая строка представляет элемент массива
    # Количество столбцов равно максимальному элементу в массиве
    max_val = max(arr)
    matrix = [[1 if arr[i] > j else 0 for j in range(max_val)] for i in range(len(arr))]

    # Шаг 2: "Падаем" бусины вниз
    # Для этого транспонируем матрицу, сортируем каждый столбец и транспонируем обратно
    transposed = list(zip(*matrix))
    sorted_transposed = [sorted(col, reverse=True) for col in transposed]
    matrix = list(zip(*sorted_transposed))

    # Шаг 3: Преобразуем матрицу обратно в отсортированный массив
    sorted_arr = [sum(row) for row in matrix]
    return sorted_arr

# Пример использования
if __name__ == "__main__":
    arr = [5, 3, 1, 4, 2]
    print("Изначальный массив:", arr)
    sorted_arr = bead_sort(arr)
    print("Отсортированный массив:", sorted_arr)


Результаты работы кода:
Изначальный массив: [5, 3, 1, 4, 2]
Отсортированный массив: [1, 2, 3, 4, 5]


поиск скачками

import math

def jump_search(arr, x):
    # Шаг 1: Определяем размер шага
    n = len(arr)
    step = int(math.sqrt(n))

    # Шаг 2: Находим блок, в котором может находиться искомый элемент
    prev = 0
    while arr[min(step, n) - 1] < x:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1

    # Шаг 3: Выполняем линейный поиск в найденном блоке
    while arr[prev] < x:
        prev += 1
        if prev == min(step, n):
            return -1

    # Шаг 4: Проверяем, найден ли элемент
    if arr[prev] == x:
        return prev
    return -1

# Пример использования
if __name__ == "__main__":
    arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
    x = 55
    result = jump_search(arr, x)
    if result != -1:
        print(f"Элемент {x} найден на позиции {result}")
    else:
        print(f"Элемент {x} не найден в массиве")


Результаты работы кода:
Элемент 55 найден на позиции 10

экспоненциальный поиск

def exponential_search(arr, x):
    # Шаг 1: Находим диапазон, в котором может находиться искомый элемент
    n = len(arr)
    if arr[0] == x:
        return 0
    i = 1
    while i < n and arr[i] <= x:
        i *= 2

    # Шаг 2: Выполняем бинарный поиск в найденном диапазоне
    left = i // 2
    right = min(i, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            left = mid + 1
        else:
            right = mid - 1

    # Шаг 3: Если элемент не найден, возвращаем -1
    return -1

# Пример использования
if __name__ == "__main__":
    arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
    x = 55
    result = exponential_search(arr, x)
    if result != -1:
        print(f"Элемент {x} найден на позиции {result}")
    else:
        print(f"Элемент {x} не найден в массиве")


Результаты работы предложенного кода:
Элемент 55 найден на позиции 10


тернарный поиск


def ternary_search(arr, x):
    # Шаг 1: Определяем начальные границы поиска
    left = 0
    right = len(arr) - 1

    # Шаг 2: Выполняем тернарный поиск
    while right >= left:
        # Определяем две точки среза
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3

        # Проверяем, в какой части массива находится искомый элемент
        if arr[mid1] == x:
            return mid1
        if arr[mid2] == x:
            return mid2

        # Обновляем границы поиска
        if x < arr[mid1]:
            right = mid1 - 1
        elif x > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1

    # Шаг 3: Если элемент не найден, возвращаем -1
    return -1

# Пример использования
if __name__ == "__main__":
    arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
    x = 55
    result = ternary_search(arr, x)
    if result != -1:
        print(f"Элемент {x} найден на позиции {result}")
    else:
        print(f"Элемент {x} не найден в массиве")


Результаты работы кода:
Элемент 55 найден на позиции 10
