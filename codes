блочная (корзинная) сортировка
def bucket_sort(arr):
    # Шаг 1: Определяем количество корзин
    # Обычно количество корзин выбирается равным длине массива
    n = len(arr)
    buckets = [[] for _ in range(n)]

    # Шаг 2: Распределяем элементы по корзинам
    # Для этого используем формулу для индекса корзины
    for num in arr:
        # Индекс корзины определяется как (число * количество корзин) / (максимальное значение + 1)
        # Это позволяет равномерно распределить элементы по корзинам
        index = int(num * n / (max(arr) + 1))
        buckets[index].append(num)

    # Шаг 3: Сортируем каждую корзину
    # Используем встроенную функцию сортировки для каждой корзины
    for i in range(n):
        buckets[i].sort()

    # Шаг 4: Собираем отсортированные элементы из корзин
    # Проходим по всем корзинам и добавляем элементы в итоговый массив
    result = []
    for bucket in buckets:
        result.extend(bucket)

    return result

# Пример использования
if __name__ == "__main__":
    arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23]
    sorted_arr = bucket_sort(arr)
    print("Отсортированный массив:", sorted_arr)
Результаты работы кода:
Исходный массив: [0.89, 0.25, 0.58, 0.99, 0.45, 0.33, 0.21, 0.8, 0.77, 0.68]
Отсортированный массив: [0.21, 0.25, 0.33, 0.45, 0.58, 0.68, 0.77, 0.8, 0.89, 0.99]


блинная сортировка

def flip(arr, k):
    # Переворачиваем первые k элементов массива
    arr[:k] = arr[:k][::-1]

def find_max_index(arr, n):
    # Находим индекс максимального элемента в неотсортированной части массива
    max_index = 0
    for i in range(n):
        if arr[i] > arr[max_index]:
            max_index = i
    return max_index

def pancake_sort(arr):
    # Основная функция блинной сортировки
    n = len(arr)
    for current_size in range(n, 1, -1):
        # Находим индекс максимального элемента в текущей неотсортированной части массива
        max_index = find_max_index(arr, current_size)
        
        # Если максимальный элемент уже на своем месте, пропускаем итерацию
        if max_index != current_size - 1:
            # Переворачиваем массив так, чтобы максимальный элемент оказался в начале
            flip(arr, max_index + 1)
            # Переворачиваем всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте
            flip(arr, current_size)

# Пример использования
if __name__ == "__main__":
    arr = [3, 6, 2, 4, 5, 1]
    pancake_sort(arr)
    print("Отсортированный массив:", arr)

Результаты работы кода:
Изначальный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]




сортировка бусинами (гравитационная)

def bead_sort(arr):
    # Шаг 1: Создаем матрицу, где каждая строка представляет элемент массива
    # Количество столбцов равно максимальному элементу в массиве
    max_val = max(arr)
    matrix = [[1 if arr[i] > j else 0 for j in range(max_val)] for i in range(len(arr))]

    # Шаг 2: "Падаем" бусины вниз
    # Для этого транспонируем матрицу, сортируем каждый столбец и транспонируем обратно
    transposed = list(zip(*matrix))
    sorted_transposed = [sorted(col, reverse=True) for col in transposed]
    matrix = list(zip(*sorted_transposed))

    # Шаг 3: Преобразуем матрицу обратно в отсортированный массив
    sorted_arr = [sum(row) for row in matrix]
    return sorted_arr

# Пример использования
if __name__ == "__main__":
    arr = [5, 3, 1, 4, 2]
    print("Изначальный массив:", arr)
    sorted_arr = bead_sort(arr)
    print("Отсортированный массив:", sorted_arr)


Результаты работы кода:
Изначальный массив: [5, 3, 1, 4, 2]
Отсортированный массив: [1, 2, 3, 4, 5]




поиск скачками
экспоненциальный поиск


тернарный поиск


