блочная (корзинная) сортировка

1.Определение алгоритма блочной (корзинной) сортировки:
Блочная (корзинная) сортировка — это алгоритм сортировки, который особенно эффективен для больших массивов данных, где элементы распределены равномерно. Основная идея заключается в том, чтобы разделить элементы на несколько "корзин" (или "блоков") ) в зависимости от диапазона их 
значений, а затем отсортировать каждую корзину отдельно. Этот алгоритм особенно полезен для сортировки чисел с плавающей точкой или других данных, которые можно равномерно распределить по диапазону.

2.Объяснение работы алгоритма:
  Распределение по корзинам: index = int(num * n / (max(arr) + 1))
        
Элементы массива распределяются по корзинам на основе их значений. Это позволяет разбить массив на более мелкие части, которые легче отсортировать.
  Сортировка каждой корзины: for i in range(n):
                             buckets[i].sort()
Каждая корзина сортируется отдельно. Это эффективно, так как корзины содержат небольшое количество элементов.
  Сборка результатов: result = []
                      result.extend(bucket)
После сортировки каждой корзины, элементы собираются в один итоговый массив, который является отсортированным.

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n + k), где n — количество элементов в массиве, а k — количество элементов в корзине. В среднем, если элементы распределены равномерно, k будет небольшим.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n + k), так как распределение по корзинам и сборка результатов занимают O(n), а сортировка каждой корзины занимает O(k).




блинная сортировка

1.Определение алгоритма блинной сортировки:
Блинная сортировка (Pancake Sort) — это алгоритм сортировки, который использует только одну операцию: переворот (flip) части массива. Основная идея заключается в том, чтобы найти максимальный элемент в неотсортированной части массива, переместить его в начало, а затем перевернуть всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте.

2.Объяснение работы алгоритма:
  Переворот максимального элемента:flip(arr, max_index + 1)
На каждой итерации мы находим максимальный элемент в неотсортированной части массива и перемещаем его в начало с помощью переворота.
  Перемещение максимального элемента на свое место:flip(arr, current_size)
После того как максимальный элемент оказался в начале, мы переворачиваем всю неотсортированную часть массива, чтобы максимальный элемент оказался на своем месте.
  Повторение процесса:
Процесс повторяется для каждой неотсортированной части массива, пока весь массив не будет отсортирован.

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n^2), так как на каждой итерации мы проходим по массиву для нахождения максимального элемента и выполняем два переворота.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n^2), так как на каждой итерации мы выполняем два переворота и находим максимальный элемент, что требует O(n) операций.


сортировка бусинами (гравитационная) 

1.Определение алгоритма сортировки бусинами (гравитационная сортировка):
Сортировка бусинами (также известная как гравитационная сортировка) — это визуальный и интуитивно понятный алгоритм сортировки, который имитирует процесс падения бусин через вертикальные стержни. Основная идея заключается в том, что бусины падают вниз, и в результате они выстраиваются в порядке возрастания.

2.Объяснение работы алгоритма:
  Создание матрицы:
    matrix = [[1 if arr[i] > j else 0 for j in range(max_val)] for i in range(len(arr))]
Мы создаем матрицу, где каждая строка представляет элемент массива. Например, для массива [5, 3, 1, 4, 2] матрица будет выглядеть так:[    
                                                                                                                                        [1, 1, 1, 1, 1],  # 5   
                                                                                                                                        [1, 1, 1, 0, 0],  # 3 
                                                                                                                                        [1, 0, 0, 0, 0],  # 1 
                                                                                                                                        [1, 1, 1, 1, 0]   # 4
                                                                                                                                        [1, 1, 0, 0, 0]   # 2 
                                                                                                                                                              ]
  "Падение" бусин вниз:
    transposed = list(zip(*matrix))
    sorted_transposed = [sorted(col, reverse=True) for col in transposed]
    matrix = list(zip(*sorted_transposed))
Мы транспонируем матрицу, сортируем каждый столбец в обратном порядке и транспонируем обратно. В результате "бусины" падают вниз, и матрица выглядит так: [    
                                                                                                                                                              [1, 1, 1, 1, 1],  # 5   
                                                                                                                                                              [1, 1, 1, 1, 0]   # 4
                                                                                                                                                              [1, 1, 1, 0, 0],  # 3
                                                                                                                                                              [1, 1, 0, 0, 0]   # 2 
                                                                                                                                                              [1, 0, 0, 0, 0]   # 1
                                                                                                                                                                                      ]

  Преобразование матрицы обратно в массив:
    sorted_arr = [sum(row) for row in matrix]
    return sorted_arr
Мы суммируем каждый ряд матрицы, чтобы получить отсортированный массив: [1, 2, 3, 4, 5].

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(n * max(arr)), где n — количество элементов в массиве, а max(arr) — максимальный элемент в массиве.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(n * max(arr)), так как мы создаем матрицу размером n * max(arr) и выполняем операции с ней.





поиск скачками
1.Определение алгоритма поиска скачками:
Поиск скачками (Jump Search) — это алгоритм поиска, который сочетает в себе элементы линейного и бинарного поиска. Основная идея заключается в том, чтобы "прыгать" по массиву с определенным шагом, а затем выполнять линейный поиск в окрестности найденного элемента.

2.Объяснение работы алгоритма:
  Определение размера шага: n = len(arr)
                            step = int(math.sqrt(n))
Мы используем квадратный корень из длины массива в качестве размера шага. Это позволяет нам эффективно "прыгать" по массиву.
  Поиск блока: 
    while arr[min(step, n) - 1] < x:
        step += int(math.sqrt(n))
Мы "прыгаем" по массиву с шагом step, пока не найдем блок, в котором может находиться искомый элемент.
  Линейный поиск в блоке:
  while arr[prev] < x:
        prev += 1
        if prev == min(step, n):
            return -1
После того как мы нашли блок, мы выполняем линейный поиск в этом блоке, чтобы найти искомый элемент.
  Проверка результата:if arr[prev] == x:
        return prev
    return -1
Если элемент найден, возвращаем его позицию. Если нет, возвращаем -1.

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(√n), где n — длина массива.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(√n), так как мы выполняем √n прыжков и линейный поиск в блоке.





экспоненциальный поиск
1.Определение алгоритма экспоненциального поиска:
Экспоненциальный поиск (Exponential Search) — это алгоритм поиска, который сочетает в себе элементы линейного и бинарного поиска. Основная идея заключается в том, чтобы сначала найти диапазон, в котором может находиться искомый элемент, а затем выполнить бинарный поиск в этом диапазоне.

2.Объяснение работы алгоритма:
  Поиск диапазона:
    if arr[0] == x:
        return 0
    while i < n and arr[i] <= x:
        i *= 2
Мы начинаем с индекса 1 и удваиваем его, пока не найдем элемент, который больше или равен искомому. Это позволяет нам найти диапазон, в котором может находиться искомый элемент.
  Бинарный поиск:
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == x:
            return mid
После того как мы нашли диапазон, мы выполняем бинарный поиск в этом диапазоне, чтобы найти искомый элемент.
  Проверка результата: 
Если элемент найден, возвращаем его позицию. Если нет, возвращаем -1.

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(log n), где n — длина массива.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(log n), так как мы выполняем log n шагов для поиска диапазона и бинарный поиск в этом диапазоне.





тернарный поиск

1.Определение алгоритма тернарного поиска:
Тернарный поиск (Ternary Search) — это алгоритм поиска, который похож на бинарный поиск, но вместо деления массива на две части, он делит его на три. Основная идея заключается в том, чтобы найти минимум или максимум функции на отрезке, используя два среза.

2.Объяснение работы алгоритма
Определение начальных границ поиска: left = 0
    right = len(arr) - 1
Мы начинаем с индекса 0 и длины массива минус 1.
Тернарный поиск: while right >= left:
  
Мы делим массив на три части и проверяем, в какой части находится искомый элемент:
        if arr[mid1] == x:
            return mid1
        if arr[mid2] == x:
            return mid2
Если элемент найден, возвращаем его позицию. Если нет, обновляем границы поиска.
Проверка результата: Если элемент не найден, возвращаем -1.

3.Оценка временной сложности алгоритма в нотации Big(O):
Среднее время работы: O(log n), где n — длина массива.

4.Краткое объяснение оценки временной сложности алгоритма:
Среднее время работы: O(log n), так как мы выполняем log n шагов для поиска элемента.



