# Локальный поиск: 1-оптимизация TSP
# Условие:
Улучшить заданный маршрут TSP, пробуя поменять пару рёбер (2-opt).
# Описание работы алгоритма:
1.Начало: Запускаем алгоритм с некоторым начальным решением (маршрутом), например, пройдя города подряд.
2.Анализируем маршруты: Перебираем все возможные пары точек i и j в маршруте и пытаемся уменьшить длину пути путём замены фрагмента пути между этими двумя точками.
Изначально имеем прямой путь вида: A0, A1, A2,..., Ai,..., Aj,..., An.
Рассматриваем альтернативный путь:A0,A1,...,Ai, Aj,...,Ai + 1,..., An. То есть меняем направление внутри промежутка [i,j].
3.Оценка изменения: Подсчитываем новую длину маршрута после такого преобразования и сравниваем её с длиной старого маршрута. Если новая длина лучше, сохраняем новое решение.
4.Продолжение поиска: Повторяем шаги 2 и 3, пока удаётся находить лучшие варианты маршрута.
5.Завершение: Когда ни одно дальнейшее улучшение невозможно, прекращаем процесс и выдаём итоговый маршрут.
# Временная сложность:
Каждая итерация включает вложенные циклы: внешний цикл перебора индекса i(0(n)) и внутренний цикл перебора индекса j (0(n)).
Внутри каждого прохода выполняется операция перевертывания части массива и подсчёт длины нового маршрута, каждая из которых тоже выполняются за линейное время относительно размера массива 0(n).
Следовательно, временная сложность отдельной итерации составляет 0(n^2).
Однако, поскольку процедура может выполняться неоднократно, общее количество итераций сложно оценить точно. Обычно оно существенно меньше квадрата числа городов, но формально верхняя граница временного поведения всего алгоритма составит 0(n^3)
# Описание временной сложности:
Общая временная сложность алгоритма составляет 
O
(
N
3
)
O(N 
3
 ), где 
N
N — количество городов. Хотя эта сложность выглядит большой, на практике алгоритм довольно быстро сходится к хорошему решению даже для десятков и сотен городов, потому что на каждом этапе проверяются лишь небольшие локальные изменения.
# Ответ на контрольный вопрос
