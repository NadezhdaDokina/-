Сортировка обменом (пузырек) (Bubble Sort)

def bubble_sort(arr):
    # Получаем длину массива
    n = len(arr)
    
    # Внешний цикл проходит по массиву столько раз,
    # сколько необходимо для полной сортировки
    for i in range(n):
        
        # Внутренний цикл проверяет пары соседних элементов и меняет их местами,
        # если первый элемент больше второго
        for j in range(0, n-i-1):   # Последний элемент каждого прохода гарантированно становится на своё место
            
            # Если текущий элемент больше следующего элемента, меняем их местами
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                
# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Отсортированный массив:", arr)



Сортировка вставками (Insertion Sort)

def insertion_sort(arr):
    # Проходим циклом по каждому элементу начиная со второго элемента (i=1)
    for i in range(1, len(arr)):
        key = arr[i]              # Берём текущий элемент (ключ), который будем вставлять
        
        j = i - 1                 # Переменная j хранит индекс предыдущего элемента

        # Цикл для перемещения всех больших элементов вправо,
        # пока мы не найдём правильную позицию для текущего ключа
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]  # Если ключ меньше текущего элемента, сдвигаем этот элемент вперёд
            j -= 1                # Переход к предыдущему элементу
            
        arr[j + 1] = key          # Вставляем ключ на нужную позицию

# Пример использования:
arr = [12, 11, 13, 5, 6]
print("Исходный массив:", arr)
insertion_sort(arr)
print("Отсортированный массив:", arr)




Сортировка Шелла


def shell_sort(arr):
    gap = len(arr) // 2  # Устанавливаем начальное расстояние (шаг) равным половине длины массива
    
    # Внешний цикл уменьшает размер шага до тех пор, пока он не станет равен нулю
    while gap > 0:
        # Вложенный цикл реализует сортировку вставками для каждой подгруппы элементов
        for i in range(gap, len(arr)):
            temp = arr[i]           # Запоминаем текущий элемент
            j = i                   # Инициализация индекса для сравнения внутри группы
            
            # Двигаясь назад по группе, выполняем перестановку элементов
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]  # Меняем местами два элемента, чтобы освободить место для вставки
                j -= gap              # Перемещаемся дальше назад по подгруппе
                
            arr[j] = temp            # Вставляем текущий элемент на свое место
        
        # Уменьшение шага (например, деление пополам)
        gap //= 2

# Пример использования:
arr = [12, 34, 54, 2, 3]
shell_sort(arr)
print("Отсортированный массив:", arr)


Последовательный поиск


def sequential_search(arr, target):
    """
    Функция осуществляет последовательный поиск целевого элемента 'target' в списке 'arr'.
    Возвращает индекс найденного элемента или None, если элемент отсутствует.
    """
    # Проходим по каждому элементу массива
    for index in range(len(arr)):   
        # Проверяем, совпадает ли текущий элемент с искомым значением
        if arr[index] == target:      
            return index              # Возвращаем индекс совпадающего элемента
    return None                      # Элемент не найден, возвращаем None


# Пример использования
my_list = [8, 2, 5, 1, 9, 4]
search_value = 5
result = sequential_search(my_list, search_value)

if result is not None:
    print(f"Значение {search_value} найдено на позиции {result}.Последовательный поиск (или линейный поиск) — простой метод нахождения заданного значения в списке путем пошагового просмотра элементов вплоть до обнаружения искомого значения либо завершения проверки всего списка.



Бинарный поиск


def binary_search(arr, target):
    low = 0                      # Нижняя граница области поиска
    high = len(arr) - 1          # Верхняя граница области поиска
    
    while low <= high:           # Повторять пока область поиска не пуста
        mid = (low + high) // 2  # Срединный индекс
        
        if arr[mid] == target:   # Нашли искомый элемент
            return mid           # Возвращаем индекс найденного элемента
        
        elif arr[mid] < target:  # Если целевой элемент больше среднего
            low = mid + 1        # Обновляем нижнюю границу
        
        else:                    # Если целевой элемент меньше среднего
            high = mid - 1       # Обновляем верхнюю границу
    
    return None                  # Элемента нет в массиве

# Пример использования:
sorted_list = [2, 4, 6, 8, 10, 12, 14]
target_value = 8
result = binary_search(sorted_list, target_value)
if result is not None:
    print(f'Искомый элемент {target_value} найден на индексе {result}')
else:
    print('Искомый элемент не найден')




Фибоначчи поиск


import math

# Генерация чисел Фибоначчи
def fibonacci_numbers(limit):
    """Генерирует ряд чисел Фибоначчи до указанного предела."""
    fib_sequence = []
    a, b = 0, 1
    while True:
        next_fib = a + b
        if next_fib >= limit:
            break
        fib_sequence.append(next_fib)
        a, b = b, next_fib
    return fib_sequence

def fibonacci_search(arr, x):
    """
    Реализует поиск методом Фибоначчи.
    :param arr: Отсортированный массив для поиска.
    :param x: Значение, которое надо найти.
    :return: Индекса элемента или -1, если элемент не найден.
    """
    m = len(arr)
    fib_seq = fibonacci_numbers(m)
    
    # Выбираем наибольшее число Фибоначчи меньше длины массива
    k = len(fib_seq)-1
    offset = -1
    
    # Основное тело поиска
    while (k > 0 and fib_seq[k] > 0):
        # Определяем точку деления массива
        i = min(offset+fib_seq[k], m-1)
        
        # Сравнение текущего элемента с искомым
        if arr[i] < x:
            # Искать вправо
            offset = i
            k -= 1
        elif arr[i] > x:
            # Искать влево
            k -= 2
        else:
            # Найдено точное совпадение
            return i
    
    # Если исчерпаны все варианты, возвращаем -1
    return -1

# Тестирование
sorted_array = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
value_to_find = 85
found_at = fibonacci_search(sorted_array, value_to_find)

if found_at != -1:
    print(f"Элемент {value_to_find} найден на позиции {found_at}")
else:
    print(f"Элемент {value_to_find} не найден")
